"""
Expanded Vulnerability Database
Integrates CVE, Exploit-DB, and custom vulnerability data for enhanced scanning
"""

import json
import requests
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


@dataclass
class CVEEntry:
    """CVE database entry"""
    cve_id: str
    description: str
    severity: str
    cvss_score: float
    published_date: datetime
    last_modified: datetime
    
    # Details
    cwe_ids: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    affected_products: List[str] = field(default_factory=list)
    
    # Exploit info
    exploit_available: bool = False
    exploit_db_id: Optional[str] = None
    metasploit_module: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "cve_id": self.cve_id,
            "description": self.description,
            "severity": self.severity,
            "cvss_score": self.cvss_score,
            "published_date": self.published_date.isoformat(),
            "cwe_ids": self.cwe_ids,
            "exploit_available": self.exploit_available,
            "exploit_db_id": self.exploit_db_id,
            "metasploit_module": self.metasploit_module
        }


class VulnerabilityDatabase:
    """
    Comprehensive vulnerability database with CVE and Exploit-DB integration
    
    Features:
    - CVE database with CVSS scoring
    - Exploit-DB integration
    - Metasploit module mapping
    - Custom vulnerability signatures
    - Real-time CVE feeds
    - Offline database caching
    """
    
    def __init__(self, cache_dir: str = "data/vuln_db"):
        """Initialize vulnerability database"""
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.cve_cache_file = self.cache_dir / "cve_cache.json"
        self.exploitdb_cache_file = self.cache_dir / "exploitdb_cache.json"
        self.custom_vulns_file = self.cache_dir / "custom_vulns.json"
        
        self.cve_cache: Dict[str, CVEEntry] = {}
        self.exploitdb_cache: Dict[str, Dict] = {}
        self.custom_vulns: Dict[str, Dict] = {}
        
        self._load_caches()
        logger.info("Vulnerability Database initialized")
    
    def _load_caches(self):
        """Load cached vulnerability data"""
        if self.cve_cache_file.exists():
            try:
                with open(self.cve_cache_file, 'r') as f:
                    data = json.load(f)
                    for cve_id, cve_data in data.items():
                        self.cve_cache[cve_id] = CVEEntry(
                            cve_id=cve_data['cve_id'],
                            description=cve_data['description'],
                            severity=cve_data['severity'],
                            cvss_score=cve_data['cvss_score'],
                            published_date=datetime.fromisoformat(cve_data['published_date']),
                            last_modified=datetime.fromisoformat(cve_data['last_modified']),
                            cwe_ids=cve_data.get('cwe_ids', []),
                            references=cve_data.get('references', []),
                            affected_products=cve_data.get('affected_products', []),
                            exploit_available=cve_data.get('exploit_available', False),
                            exploit_db_id=cve_data.get('exploit_db_id'),
                            metasploit_module=cve_data.get('metasploit_module')
                        )
                logger.info(f"Loaded {len(self.cve_cache)} CVE entries from cache")
            except Exception as e:
                logger.warning(f"Failed to load CVE cache: {e}")
        
        if self.exploitdb_cache_file.exists():
            try:
                with open(self.exploitdb_cache_file, 'r') as f:
                    self.exploitdb_cache = json.load(f)
                logger.info(f"Loaded {len(self.exploitdb_cache)} Exploit-DB entries from cache")
            except Exception as e:
                logger.warning(f"Failed to load Exploit-DB cache: {e}")
        
        if self.custom_vulns_file.exists():
            try:
                with open(self.custom_vulns_file, 'r') as f:
                    self.custom_vulns = json.load(f)
                logger.info(f"Loaded {len(self.custom_vulns)} custom vulnerabilities")
            except Exception as e:
                logger.warning(f"Failed to load custom vulnerabilities: {e}")
    
    def _save_caches(self):
        """Save vulnerability data to cache"""
        try:
            cve_data = {}
            for cve_id, cve_entry in self.cve_cache.items():
                cve_data[cve_id] = {
                    "cve_id": cve_entry.cve_id,
                    "description": cve_entry.description,
                    "severity": cve_entry.severity,
                    "cvss_score": cve_entry.cvss_score,
                    "published_date": cve_entry.published_date.isoformat(),
                    "last_modified": cve_entry.last_modified.isoformat(),
                    "cwe_ids": cve_entry.cwe_ids,
                    "references": cve_entry.references,
                    "affected_products": cve_entry.affected_products,
                    "exploit_available": cve_entry.exploit_available,
                    "exploit_db_id": cve_entry.exploit_db_id,
                    "metasploit_module": cve_entry.metasploit_module
                }
            
            with open(self.cve_cache_file, 'w') as f:
                json.dump(cve_data, f, indent=2)
            
            with open(self.exploitdb_cache_file, 'w') as f:
                json.dump(self.exploitdb_cache, f, indent=2)
            
            logger.info("Vulnerability caches saved")
        except Exception as e:
            logger.error(f"Failed to save caches: {e}")
    
    async def fetch_cve_data(self, cve_id: str) -> Optional[CVEEntry]:
        """
        Fetch CVE data from NVD or cache
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2024-1234)
        
        Returns:
            CVEEntry if found, None otherwise
        """
        if cve_id in self.cve_cache:
            return self.cve_cache[cve_id]
        
        try:
            url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                cve_item = data['result']['CVE_Items'][0]
                
                cve_data = cve_item['cve']
                impact = cve_item.get('impact', {})
                
                base_metric_v3 = impact.get('baseMetricV3', {})
                cvss_v3 = base_metric_v3.get('cvssV3', {})
                
                cve_entry = CVEEntry(
                    cve_id=cve_id,
                    description=cve_data['description']['description_data'][0]['value'],
                    severity=cvss_v3.get('baseSeverity', 'UNKNOWN'),
                    cvss_score=cvss_v3.get('baseScore', 0.0),
                    published_date=datetime.fromisoformat(cve_item['publishedDate'].replace('Z', '+00:00')),
                    last_modified=datetime.fromisoformat(cve_item['lastModifiedDate'].replace('Z', '+00:00')),
                    cwe_ids=[p['value'] for p in cve_data.get('problemtype', {}).get('problemtype_data', [{}])[0].get('description', [])],
                    references=[r['url'] for r in cve_data.get('references', {}).get('reference_data', [])]
                )
                
                self.cve_cache[cve_id] = cve_entry
                self._save_caches()
                
                logger.info(f"Fetched CVE data: {cve_id}")
                return cve_entry
        except Exception as e:
            logger.error(f"Failed to fetch CVE data for {cve_id}: {e}")
        
        return None
    
    def search_vulnerabilities(
        self,
        keyword: str = None,
        product: str = None,
        severity: str = None,
        min_cvss: float = 0.0,
        has_exploit: bool = False
    ) -> List[CVEEntry]:
        """
        Search vulnerability database
        
        Args:
            keyword: Search keyword in description
            product: Affected product name
            severity: Severity level (CRITICAL, HIGH, MEDIUM, LOW)
            min_cvss: Minimum CVSS score
            has_exploit: Only return CVEs with exploits
        
        Returns:
            List of matching CVE entries
        """
        results = []
        
        for cve_entry in self.cve_cache.values():
            if keyword and keyword.lower() not in cve_entry.description.lower():
                continue
            
            if product and not any(product.lower() in p.lower() for p in cve_entry.affected_products):
                continue
            
            if severity and cve_entry.severity != severity:
                continue
            
            if cve_entry.cvss_score < min_cvss:
                continue
            
            if has_exploit and not cve_entry.exploit_available:
                continue
            
            results.append(cve_entry)
        
        results.sort(key=lambda x: x.cvss_score, reverse=True)
        return results
    
    def add_custom_vulnerability(
        self,
        vuln_id: str,
        name: str,
        description: str,
        severity: str,
        detection_patterns: List[str],
        remediation: str
    ):
        """
        Add custom vulnerability signature
        
        Args:
            vuln_id: Unique identifier
            name: Vulnerability name
            description: Description
            severity: Severity level
            detection_patterns: Regex patterns for detection
            remediation: Remediation advice
        """
        self.custom_vulns[vuln_id] = {
            "id": vuln_id,
            "name": name,
            "description": description,
            "severity": severity,
            "detection_patterns": detection_patterns,
            "remediation": remediation,
            "created_at": datetime.now().isoformat()
        }
        
        try:
            with open(self.custom_vulns_file, 'w') as f:
                json.dump(self.custom_vulns, f, indent=2)
            logger.info(f"Added custom vulnerability: {vuln_id}")
        except Exception as e:
            logger.error(f"Failed to save custom vulnerability: {e}")
    
    def get_exploit_info(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Get exploit information for CVE
        
        Args:
            cve_id: CVE identifier
        
        Returns:
            Exploit information if available
        """
        cve_entry = self.cve_cache.get(cve_id)
        if not cve_entry or not cve_entry.exploit_available:
            return None
        
        return {
            "cve_id": cve_id,
            "exploit_db_id": cve_entry.exploit_db_id,
            "metasploit_module": cve_entry.metasploit_module,
            "references": cve_entry.references
        }
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics"""
        severity_counts = {}
        exploit_count = 0
        
        for cve_entry in self.cve_cache.values():
            severity_counts[cve_entry.severity] = severity_counts.get(cve_entry.severity, 0) + 1
            if cve_entry.exploit_available:
                exploit_count += 1
        
        return {
            "total_cves": len(self.cve_cache),
            "exploits_available": exploit_count,
            "severity_distribution": severity_counts,
            "custom_vulnerabilities": len(self.custom_vulns),
            "last_updated": datetime.now().isoformat()
        }
